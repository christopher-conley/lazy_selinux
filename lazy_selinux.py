#!/usr/bin/env python3
"""
lazy_selinux.py

A Python script to search logfiles for SELinux denials and auto-generate SELinux modules for them.
This script is intended to be ran as a cron job, and will search for SELinux denials in 
the logfile specified in the config file.
"""

import os
import sys
import argparse
from os.path import exists as exists
from os import path as path, makedirs as makedirs, access as access, R_OK as R_OK
from sys import exc_info as exc_info
from pathlib import Path
from datetime import datetime
from inspect import currentframe
from include.classes_and_functions import (
    ScriptGlobals,
    print_and_log,
    find_selinux_denials,
    generate_selinux_module,
    send_alert_email,
)

# pylint: disable=line-too-long

SELF_NAME = f"{str(currentframe().f_code.co_name)}()"
script_name = path.basename(sys._getframe(0).f_globals["__file__"])
script_basename = script_name.split(".")[0]
start_time = datetime.now()

parser = argparse.ArgumentParser(
    description="Search for SELinux denials and autocreate pp files",
    epilog="This script WILL NOT auto-insert modules without specifying the [-i|--insert-modules] commandline flag, and doing that is probably a bad idea; that's why it's off by default. Arguments provided on the commandline at runtime will override options set in the YAML config file.",
)

parser.add_argument(
    "-c",
    "--config-file",
    required=False,
    action="store",
    help=f"Path to YAML config file. Defaults to: ~/.automation/python/config/{script_basename}/{script_basename}.yml",
)

parser.add_argument(
    "-e",
    "--expression",
    nargs=1,
    type=str,
    required=False,
    action="store",
    help="Regex match expression to search for in logfile. Defaults to a string way too long for this help message.",
)

parser.add_argument(
    "-E",
    "--email-from",
    nargs=1,
    type=str,
    required=False,
    action="store",
    help="Email address to send notifications from. Also used as the username for SMTP authentication.",
)

parser.add_argument(
    "-g",
    "--generation-record",
    nargs=1,
    type=str,
    required=False,
    action="store",
    help=f"Path to file where a record of generated modules will be stored. Defaults to: ~/.automation/python/logs/{script_basename}/autogenerated_selinux_modules.yml",
)

parser.add_argument(
    "-i",
    "--insert-modules",
    required=False,
    action="store_true",
    help="Take your laziness to the next level and auto-insert modules. You probably shouldn't do this, but the option is here if you want to be dangerous and lazy.",
)

parser.add_argument(
    "-L",
    "--log-file",
    nargs=1,
    type=str,
    required=False,
    action="store",
    help=f"Path to file where the script will log its output. Defaults to: ~/.automation/python/logs/{script_basename}/{script_name}.log",
)

parser.add_argument(
    "-m",
    "--modules-dir",
    nargs=1,
    type=str,
    required=False,
    action="store",
    help="Where to store auto-generated SELinux modules. Defaults to: ~/generated_selinux_modules",
)

parser.add_argument(
    "-r",
    "--recipients",
    nargs=1,
    type=str,
    required=False,
    action="store",
    help="Comma-separated list (string) of recipients to receive email notifications. Specify with or without spaces after commas.",
)

parser.add_argument(
    "-s",
    "--search-logfile",
    nargs=1,
    type=str,
    required=False,
    action="store",
    help="Logfile to search for SELinux denials. Defaults to: /var/log/messages",
)

parser.add_argument(
    "-S",
    "--smtp-server",
    nargs=1,
    type=str,
    required=False,
    action="store",
    help="SMTP server to use for sending email notifications.",
)

parser.add_argument(
    "-v",
    "--version",
    required=False,
    action="store_true",
    help="Show version information and exit. This isn't a verbose flag, this script is all verbose all the time.",
)

# version = datetime.now().strftime('%Y.%m.%d.%H%M')
VERSION = "2024.04.05.0318"

args = parser.parse_args()
if args.version:
    print(f"{script_name} v{VERSION}")
    sys.exit(0)

settings = ScriptGlobals(args)

# For debugging
# print("\n\n")
# for cproperty, value in vars(settings).items():
#     print(cproperty, ":", value)
#     print("\n")
# print("\n")

if (not exists(settings.log_file)) or (not exists(settings.modules_dir)):
    settings.create_local_files()

print_and_log(
    SELF_NAME,
    f"Script started with arguments: {args}\n",
    settings=settings,
    log_file=settings.log_file,
)

if not exists(settings.search_logfile):
    print_and_log(
        SELF_NAME,
        f"Logfile to parse at {settings.search_logfile} does not exist. Exiting.",
        settings=settings,
        log_file=settings.log_file,
    )
    sys.exit(1)
elif not access(settings.search_logfile, R_OK):
    print_and_log(
        SELF_NAME,
        f"User {os.getenv('USER')} has no permission to read logfile at {settings.search_logfile}, Exiting.",
        settings=settings,
        log_file=settings.log_file,
    )
    sys.exit(1)

settings.selinux_matches = find_selinux_denials(settings=settings)
if settings.mail.num_matches == 0:
    print_and_log(
        SELF_NAME,
        f"No matches found in logfile: {settings.search_logfile}",
        settings=settings,
        log_file=settings.log_file,
    )
    sys.exit(0)

print_and_log(
    SELF_NAME,
    f"Found {settings.mail.num_matches} matches out of {settings.mail.num_lines} lines in logfile: {settings.search_logfile}\n\n",
    settings=settings,
    log_file=settings.log_file,
)

for denial_match in settings.selinux_matches[0]:

    with open(file=settings.matches_file, mode="r", encoding="ascii") as in_file:
        yaml_matches = settings.read_yaml_file(
            settings.matches_file, is_match_file=True
        )
    in_file.close()

    if not yaml_matches.generated_modules is None:
        for ymatch in yaml_matches.generated_modules:
            settings.yaml_digests.append(ymatch["hexdigest"])

    try:
        if yaml_matches.generated_modules is None:
            print_and_log(
                SELF_NAME,
                f"Matches file is empty, generating module for match with hexdigest {denial_match.hexdigest}",
                settings=settings,
                log_file=settings.log_file,
            )
            generate_selinux_module(selinux_match=denial_match, settings=settings)
            continue
        if denial_match.hexdigest in settings.yaml_digests:
            print_and_log(
                SELF_NAME,
                f"Match with hexdigest {denial_match.hexdigest} already exists in matches file, skipping",
                settings=settings,
                log_file=settings.log_file,
            )
            settings.mail.duplicates += 1
            continue

        print_and_log(
            SELF_NAME,
            f"Match with hexdigest {denial_match.hexdigest} does not exist in matches file, generating module",
            settings=settings,
            log_file=settings.log_file,
        )
        generate_selinux_module(selinux_match=denial_match, settings=settings)

    except Exception as e:
        print_and_log(
            SELF_NAME,
            f"Exception: {exc_info()[0]}: {e}",
            settings=settings,
            log_file=settings.log_file,
        )
        continue

if settings.mail.num_modules_generated != 0:
    settings.mail.subject = f"{settings.mail.num_modules_generated} new SELinux modules generated for {settings.hostname}"
    settings.end_time = str(datetime.now() - start_time)
    if os.getenv('SELINUX_SMTP_PASSWORD') is not None:
        send_alert_email(settings)
        print("Notification email sent, exiting.")
        sys.exit(0)
else:
    print("No new modules generated, exiting.")
    sys.exit(0)
